<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://brashandplucky.com/feed.xml" title="Chema Guerra" /><!-- favicon -->
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!-- MathJax -->
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Open Graph cards -->
    <meta property="og:url" content="https://brashandplucky.com/2025/09/07/procedural-island-generation-i.html">
    <meta property="og:title" content="Procedural Island Generation (I)">
    <meta property="og:description" content="This is a coding blog where I post about the various projects that I am currently working on, both at work, or as an independent researcher. Most content here revolves around computer graphics and physics simulation.">
    <meta property="og:image" content="https://brashandplucky.com/thumbnails/2025/chemaguerra-procedural-island-generation-i.png">
    <meta property="og:type" content="article">
    <!-- Twitter cards -->
    <meta name="twitter:site" content="@chemaguerra">
    <meta name="twitter:creator" content="@Chema Guerra">
    <meta name="twitter:title" content="Procedural Island Generation (I)">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="This is a coding blog where I post about the various projects that I am currently working on, both at work, or as an independent researcher. Most content here revolves around computer graphics and physics simulation.">
    <meta name="twitter:image" content="https://brashandplucky.com/thumbnails/2025/chemaguerra-procedural-island-generation-i.png">
    <meta name="twitter:image:src" content="https://brashandplucky.com/thumbnails/2025/chemaguerra-procedural-island-generation-i.png">
    
    <!-- Make post images clickable to enlarge -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Find all images in post content.
      var images = document.querySelectorAll('.post-content img');
      
      images.forEach(function(img) {
        // Skip if already wrapped in a link.
        if (img.parentElement.tagName === 'A') return;
        
        // Create link wrapper.
        var link = document.createElement('a');
        link.href = img.src;
        link.target = '_blank';
        link.title = 'Click to enlarge';
        
        // Wrap image with link.
        img.parentNode.insertBefore(link, img);
        link.appendChild(img);
        
        // Add cursor style.
        img.style.cursor = 'zoom-in';
      });
      
      // Make all external links open in new tab.
      var links = document.querySelectorAll('.post-content a, .page-content a');
      links.forEach(function(link) {
        // Check if link is external (not same domain).
        if (link.hostname && link.hostname !== window.location.hostname) {
          link.target = '_blank';
          link.rel = 'noopener noreferrer';
        }
      });
    });
    </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chema Guerra</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/archive/">Archive</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Procedural Island Generation (I)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-09-07T00:00:00+02:00" itemprop="datePublished">Sep 7, 2025
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Chema Guerra</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-procedural-island-generation-terrain-mesh.png" alt="Terrain mesh visualization" /></p>

<p>This post marks the beginning of a series on procedural island generation. I recently fell in love with <a href="https://twitter.com/redblobgames">Amit Patel’s</a> brilliant <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">polygon map generation</a> articles, and this series will be my own exploration and interpretation of those techniques.</p>

<p>This series assumes familiarity with computational geometry and procedural generation concepts such as Delaunay triangulation, Voronoi diagrams, FBM, etc…</p>

<p>To challenge myself (I’m usually a C/C++ person), I decided to implement this in Rust. But I will barely delve into implementation details though. This series will focus on the algorithm itself, with neat (hopefully!) visualizations of the intermediate calculations.</p>

<h2 id="motivation">Motivation</h2>

<p>The main reason why I am tinkering with terrain generation now is <strong>Strike Back</strong>, the <a href="https://x.com/topotoylabs/status/1750315804170612745">flight sim I’ve been developing on and off</a>. I will be using this algorithm as a foundation to create battle arenas which I plan to extend eventually.</p>

<h3 id="working-domain">Working Domain</h3>

<p>Procedural terrain generation offers infinite variety from finite code. But islands make particularly interesting subjects because they’re self-contained worlds with natural boundaries. The polygon-based approach we’ll explore provides a nice balance between organic appearance and computational tractability.</p>

<p>We’ll work in a <em>regular grid</em> within a <em>unit square domain</em>. While regular grids are the classic approach for terrain generation (much simpler implementation, no topological headaches), irregular grids produce far more organic-looking geometry. That’s what we’re after.</p>

<p>Irregular grids have been having a moment lately, BTW. Especially since <a href="https://store.steampowered.com/app/1291340/Townscaper/">Townscaper</a> captured everyone’s imagination.</p>

<h2 id="seed-point-generation">Seed Point Generation</h2>

<p>The foundation of an organic-looking terrain mesh is the distribution of its vertices. Random point placement leads to ugly, irregular triangulation. We need something better. Ideally, we need points that are random yet evenly spaced. This is where blue noise comes in.</p>

<h3 id="blue-noise-and-poisson-disk-sampling">Blue Noise and Poisson Disk Sampling</h3>

<p>Blue noise distributions have a specific property: points maintain a minimum distance from each other whilst filling space uniformly. No clumping, no voids. The spectrum of blue noise is weighted toward higher frequencies, which translates visually to pleasant, nature-resembling distributions.</p>

<p>Bridson’s algorithm for Poisson disk sampling is elegantly simple:</p>

<ol>
  <li>Start with a random initial point</li>
  <li>Generate candidate points in an annulus around existing points</li>
  <li>Accept candidates that are far enough from all existing points</li>
  <li>Repeat until no valid candidates remain</li>
</ol>

<p>The key parameters are:</p>
<ul>
  <li>\(r\): minimum distance acceptable between points</li>
  <li>\(k\): number of candidates to try before rejection (typically 30)</li>
</ul>

<p>The algorithm maintains an “active list” of points that might still have valid neighbors. When a point fails to produce valid candidates after \(k\) attempts, it is removed from the active list.</p>

<p>Spatial indexing is crucial for efficient nearest-neighbor queries in Bridson’s algorithm. A simple grid works well: divide space into cells of size \(r/\sqrt{2}\), ensuring at most one point per cell for \(O(1)\) lookups.</p>

<p>Below is an auxiliary visualization animation I wrote in Python:</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-bridson-algorithm.gif" alt="Bridson's algorithm in action" /></p>

<h3 id="lloyds-relaxation">Lloyd’s Relaxation</h3>

<p>There are different families of algorithms for blue noise generation. Dart-throwing methods, void-and-cluster, Fourier-based methods, relaxation methods, …</p>

<p>While we will stick to Bridson’s algorithm as described above, I am fond of Lloyd’s relaxation (also known as Voronoi iteration). And because we will be working with the Voronoi diagram later I thought it would be worth mentioning.</p>

<p>The process is beautifully simple:</p>
<ol>
  <li>Start with any set of random points.</li>
  <li>Compute the Voronoi diagram for current points</li>
  <li>Move each point to the centroid of its Voronoi cell</li>
  <li>Repeat until convergence</li>
</ol>

<p>This iterative process naturally evolves toward a hexagonal-dominant grid; the most efficient packing in 2D.</p>

<p>Below is another animation I made in Python:</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-lloyd-relaxation.gif" alt="Lloyd's relaxation with Voronoi cells visible" /></p>

<p>Lloyd’s relaxation is computationally expensive and produces overly regular distributions that can look artificial for terrain. Bridson strikes a better balance: it’s fast and maintains the organic irregularity we want.</p>

<h2 id="boundary-treatment">Boundary Treatment</h2>

<p>Instead of letting Poisson disk sampling run across the entire domain, I restrict it to a shrunk area, leaving a gap of radius \(r\) around the edges. Then I add two rings of evenly-spaced points: one at the boundary itself (green), and another ring \(r\) units outside the domain (red).</p>

<p>This approach ensures full coverage with well-behaved triangles at the edges for Delaunay triangulation and simplifies handling of unbounded Voronoi regions.</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-bridson-separation.gif" alt="Point separation constraint during generation" /></p>

<p>In the animation above, working with a unit square domain and \(r = \frac{1}{200}\), we’d theoretically fit up to \(\left(\frac{1}{r}\right)^2 = 200^2 = 40000\) points in a perfect grid. But Poisson disk sampling produces a looser packing. With the annulus radius range \([r, 2r]\) and rejection sampling, we get ~27000 points in practice, about 68% of the theoretical maximum.</p>

<h2 id="delaunay-triangulation">Delaunay Triangulation</h2>

<p>With our well-distributed seed points, we need to create a mesh. Delaunay triangulation is the go-to choice for terrain generation because it maximizes the minimum angle of all triangles, avoiding skinny, degenerate triangles that cause numerical and visual issues.</p>

<p>In the visualizations throughout this post, red dots will represent seed points (Delaunay vertices), while blue dots will represent Voronoi vertices (corresponding to Delaunay triangle centers).</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-delaunay-static.png" alt="Delaunay triangulation static view" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-delaunay-tile.png" alt="Delaunay triangulation detail view" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-delaunay-mesh.gif" alt="Delaunay triangulation mesh" /></p>

<p>For the implementation, I went with Rust’s <code class="language-plaintext highlighter-rouge">delaunator</code> crate. It’s a robust, battle-tested port of the JavaScript library of the same name, implementing a fast sweep-line algorithm that runs in \(O(n \log n)\) time. The cyclic animation is just the same code but decreasing/increasing \(r\) (more/fewer points).</p>

<h2 id="voronoi-diagram">Voronoi Diagram</h2>

<p>The Voronoi diagram is the dual of the Delaunay triangulation. Each Delaunay triangle vertex becomes a Voronoi cell, and each Delaunay edge corresponds to a Voronoi edge. For terrain generation, Voronoi cells are a staple: they define convex-shaped regions around each seed point, perfect for assigning terrain properties like elevation, moisture, and biome types.</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-voronoi-full.png" alt="Voronoi cells full view" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-voronoi-circumcenters-tile.png" alt="Voronoi with circumcenters detail view" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-voronoi-cells.gif" alt="Voronoi cells diagram" /></p>

<p>Rather than using an off-the-shelf solution, I built the dual construction using my topology library <strong>TopoKit</strong>, recently ported to Rust. The half-edge (DCEL) data structure I have there makes it trivial to traverse neighbors, and maintain the topological relationships we need for terrain generation. TopoKit also handles serialization, relaxation, LOD subdivision, and other features I’ll tap into later.</p>

<h2 id="circumcenters-vs-centroids">Circumcenters vs. Centroids</h2>

<p>The classical Voronoi diagram uses triangle circumcenters as Voronoi vertices. The circumcenter is equidistant from all three triangle vertices, making it the natural meeting point of three Voronoi cells. However the circumcenter potentially lies outside its triangle if it is obtuse enough. For very flat triangles near boundaries, circumcenters can be far from their triangles, sometimes even outside the domain entirely.</p>

<p>A clever trick I learned from <a href="https://twitter.com/redblobgames">@redblobgames</a> is using triangle centroids instead of circumcenters for Voronoi vertices. This simple change produces smoother, more bubble-like regions with gentler transitions between cells. These softer angles are ideal for terrain generation, and the computation is actually simpler.</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-voronoi-centroids.png" alt="Voronoi diagram using centroids" /></p>

<p>Here’s the main takeaway (an animated comparison):</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-voronoi-comparison.gif" alt="Voronoi comparison: circumcenters vs centroids" /></p>

<p>We will go with centroids (instead of circumcenters) for the rest of the series.</p>

<h2 id="quad-mesh-construction">Quad Mesh Construction</h2>

<p>So we have:</p>
<ul>
  <li><strong>Red vertices</strong>: Original seed points (Delaunay vertices)</li>
  <li><strong>Blue vertices</strong>: Voronoi vertices (triangle centers)</li>
</ul>

<p>Both vertex sets contribute to the final terrain mesh. Throughout this series, we’ll compute attributes like elevation for both red and blue vertices, then triangulate the combined point set to generate the final terrain geometry.</p>

<h3 id="the-red-blue-pattern">The Red-Blue Pattern</h3>

<p>A natural way to combine both the Delaunay and Voronoi meshes is to form quads by each red-blue-red-blue cycle, traversing around shared edges:</p>

<ol>
  <li>Start with a Delaunay edge connecting two red vertices</li>
  <li>This edge is dual to a Voronoi edge connecting two blue vertices</li>
  <li>The four vertices form a natural quad: red-blue-red-blue</li>
</ol>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-quads-static.png" alt="Quad mesh static view" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-quads-tile.png" alt="Quad mesh detail view" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-quad-mesh.gif" alt="Quad mesh with red-blue vertex pattern" /></p>

<p>In the resulting quad mesh:</p>
<ul>
  <li>Red vertices have high valence (many incident edges)</li>
  <li>Blue vertices typically have valence 3 (from triangle origins)</li>
  <li>Edge flow follows a characteristic diamond pattern</li>
</ul>

<h2 id="mountain-peak-seed-points">Mountain Peak Seed Points</h2>

<p>To generate realistic terrain with well-placed mountain peaks, we must flag a special subset of seed points that will become elevation maxima. This two-scale approach ensures mountains maintain natural spacing while aligning perfectly with our existing mesh vertices.</p>

<p>The process leverages a second Bridson’s algorithm run with a much larger radius, typically 4-16 times the original \(r\). This coarse distribution determines where mountain peaks should roughly appear, ensuring they maintain natural spacing across the terrain.</p>

<p>Here’s the algorithm:</p>
<ol>
  <li>Build a kD-tree from the fine-grain seed points for efficient nearest-neighbor queries</li>
  <li>Run Bridson’s algorithm with radius \(R \gg r\) to get coarse peak candidates</li>
  <li>For each coarse candidate, find its nearest neighbor in the fine distribution</li>
  <li>Flag these nearest neighbors as mountain peak seeds</li>
</ol>

<p>Spacial hashing (the kD-tree in my case) is crucial here for performance. With thousands of seed points, nearest-neighbor search would be prohibitively slow otherwise.</p>

<p>This approach has several advantages:</p>
<ul>
  <li>Natural spacing: Mountains won’t cluster unnaturally or leave large empty regions</li>
  <li>Mesh alignment: Peak points are actual mesh vertices, not interpolated positions</li>
  <li>Controllable density: Adjusting \(R\) directly controls mountain frequency</li>
  <li>Reproducible: Given the same random seed, peak placement is deterministic</li>
</ul>

<p>These flagged mountain peaks will later serve as local maxima during elevation assignment, with height falloff based on distance. But that’s a topic for Part II.</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-mountain-peak-separation.gif" alt="Mountain peak points with varying separation radius" /></p>

<p>Above is an animation with varying mountain separation \(R\) over the same set of regular seed points.</p>

<h2 id="next-steps">Next Steps</h2>

<p>This is the type of distribution (~27000 points) we will be using throughout the rest of the series.</p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-mountain-seed-points.png" alt="Mountain peak seed points visualization" /></p>

<p><img src="/uploads/2025/procedural-island-generation-i/chemaguerra-seed-points-tile.png" alt="Mountain peak seed points detail view" /></p>

<p>With our mesh structures in place we have the skeletal framework for our island. Part II will dive into elevation assignment using noise functions, creating realistic height maps that produce convincing mountains, valleys, and coastlines.</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">Amit Patel’s Polygon Map Generation</a> - The inspiration for this series</li>
  <li><a href="https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf">Bridson’s Original Paper</a> - Fast Poisson disk sampling</li>
  <li><a href="https://en.wikipedia.org/wiki/Lloyd%27s_algorithm">Lloyd’s Algorithm</a> - The mathematical foundation</li>
</ul>

  </div><a class="u-url" href="/2025/09/07/procedural-island-generation-i.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Chema Guerra</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Chema Guerra</li><li><a class="u-email" href="mailto:brashandplucky@gmail.com">brashandplucky@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/chemaguerra"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">chemaguerra</span></a></li><li><a href="https://www.twitter.com/chemaguerra"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">chemaguerra</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is a coding blog where I post about the various projects that I am currently working on, both at work, or as an independent researcher. Most content here revolves around computer graphics and physics simulation.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
